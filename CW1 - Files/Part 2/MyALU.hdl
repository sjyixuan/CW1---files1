
/**
 * The MyALU. is the ALU of YOUR OWN design that provides the same functions as in the Nand2Tetris project + additional functions (and uses different control bits.
 * Computes one of the following functions:
 * x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y,
 * x+1, y+1, x-1, y-1, x&y, x|y , x XOR y, on two 16-bit inputs, 
 * according to 6 input bits denoted zx,nx,zy,ny,f,no.
 * In addition, the ALU computes two 1-bit outputs:
 * if the ALU output == 0, zr is set to 1; otherwise zr is set to 0;
 * if the ALU output < 0, ng is set to 1; otherwise ng is set to 0.
 */

// Implementation: the ALU logic manipulates the x and y inputs


CHIP MyALU {
    IN  
        x[16], y[16],  // 16-bit inputs        
        C0, // Control Bit 0 (Least significant) 
        C1, // Control Bit 1
        C2, // Control Bit 2
        C3,  // Control Bit 3
		C4,  // Control Bit 4 (Most significant - 5th Control bit)
        

    OUT 
        out[16], // 16-bit output
        zr, // 1 if (out == 0), 0 otherwise
        ng; // 1 if (out < 0),  0 otherwise

    PARTS:

   Not16(in=x, out=nx);
   Not16(in=y, out=ny);


   Inc16(in=nx, out=negatedx);
   Inc16(in=ny, out=negatedy); 
   

   Inc16(in=x, out=xplusone);
   Inc16(in=y, out=yplusone);
   
   Add16(a=x,b=negatedx,out=xminusone);
   Add16(a=y,b=negatedx,out=yminusone);


   Add16(a=x,b=y,out=xplusy);

   Add16(a=x,b=negatedy,out=xminusy);
   Add16(a=y,b=negatedx,out=yminusx);

   And16(a=x,b=y,out=xandy);

   Or16(a=x,b=y,out=xory);

   And16(a=x, b=y, out=xor1);
   Not16(in=xor1, out=xor2);
   Or16(a=x, b=y, out=xor3);
   And16(a=xor2, b=xor3, out=xxory);

   Mux16(a=false,b=true,sel=C0,out=output1);
   Mux16(a=negatedx,b=x,sel=C0,out=output2);
   Mux16(a=output1,b=output2,sel=C1,out=output3);

   Mux16(a=y,b=nx,sel=C0,out=output4);
   Mux16(a=ny,b=negatedx, sel=C0,out=output5);
   Mux16(a=output4,b=output5,sel=C1,out=output6);


   Mux16(a=negatedy,b=xplusone,sel=C0,out=output7);
   Mux16(a=yplusone,b=xminusone, sel=C0,out=output8);
   Mux16(a=output7,b=output8,sel=C1,out=output9);

   Mux16(a=yminusone,b=xplusy,sel=C0,out=output10);
   Mux16(a=xminusy,b=yminusx, sel=C0,out=output11);
   Mux16(a=output10,b=output11,sel=C1,out=output12);

   Mux16(a=xandy,b=xory,sel=C0,out=output13);
   Mux16(a=xxory,b=false, sel=C0,out=output14);
   Mux16(a=output13,b=output14,sel=C1,out=output15);


   Mux16(a=output3,b=output6,sel=C2,out=output16);
   Mux16(a=output9,b=output12,sel=C2,out=output17);
   Mux16(a=output16,b=output17,sel=C3,out=output18);

   Mux16(a=output18, b=output15, sel=C4, out=out, out[15]=firstOut,out[0..7]=finalLeft,out[8..15]=finalRight);

    //output==0 (zr)
    //Or8Way(in=finalLeft, out=zrl);
    //Or8Way(in=finalRight, out=zrr);
    /Or(a=zrl, b=zrr, out=nzr);
    //Not(in=nzr, out=zr);

    // Calculate MSB separately
    //Or8Way(in=finalLeft, out=msb_low);  // Identify MSB for the least significant bits
    //Or8Way(in=finalRight, out=msb_high);  // Identify MSB for the most significant bits

    //Or(in=msb_low, b=msb_high, out=msb);  // OR the MSBs of both parts

    // Set ng to 1 if MSB is 1, indicating a negative number
    //Or(in=msb, b=false, out=ng);


//output==0 (zr)
Or8Way(in=finalLeft, out=zrl);
Or8Way(in=finalRight, out=zrr);
Or(a=zrl, b=zrr, out=nzr);
Not(in=nzr, out=zr);

// Calculate MSB separately
Or8Way(in=finalLeft, out=msb_low);  // Identify MSB for the least significant bits
Or8Way(in=finalRight, out=msb_high);  // Identify MSB for the most significant bits

Or(in=msb_low, b=msb_high, out=msb);  // OR the MSBs of both parts

// Set ng to 1 if MSB is 1, indicating a negative number
Or(in=msb, b=false, out=ng);

}
